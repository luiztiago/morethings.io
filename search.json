[
	
		{
		  "title"      : "Como medir performance da sua aplicação usando User Timing API",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/como-medir-performance-da-sua-aplicacao-usando-user-timing-api",
		  "date"       : "2014-01-23 09:00:00 UTC",
		  "shortdate"  : "January 23, 2014",
		  "content"    : "Como medir performance da sua aplicação usando User Timing APISe você deseja ter uma boa user experience em sua aplicação, é fundamental investir em performance. E para otimizá-la, você precisa ter números medidos e estes precisam ser bem precisos, para ajudar a encontrar os gargalos, fazer as melhorias e comparar os resultados. Mas como fazer estas medições com JavaScript?Abaixo seguem duas formas, que são as mais conhecidas, onde os desenvolvedores já usam há algum tempo. E logo após, apresento como utilizar a User Timing API, que foi divulgada há pouco mais de um mês.Usando DOMTimeStamp com Date.now()Durante muito tempo, os desenvolvedores usavam o Date.now para fazer estas medições. Abaixo podemos ver um exemplo comparando o tempo de execução de cada uma das funções foo() e bar().var startTime = Date.now();foo();var test1 = Date.now();bar();var test2 = Date.now();console.debug(&quot;Test1 time: &quot; + (test1 - startTime));console.debug(&quot;Test2 time: &quot; + (test2 - test1));O DOMTimeStamp retorna um número inteiro do tempo em milisegundos, que por sua vez, não possui muita precisão. E pra piorar, esta precisão varia entre os user agents, tornando-se não muito confiável.Usando DOMHighResTimeStamp com performance.now()Afim de proporcionar uma maior precisão, um novo tipo chamado DOMHighResTimeStamp foi criado. O valor retornado também é em milissegundos, só que desta vez é um float, aumentando a precisão para um milésimo de milésimo de segundo. Como o Paul Irish mencionou “When milliseconds are not enough” num post com este título. O código abaixo mostra um exemplo bem semelhante com o acima, porém desta vez, um pouco mais preciso.var startTime = performance.now();foo();var test1 = performance.now();bar();var test2 = performance.now();console.debug(&quot;Test1 time: &quot; + (test1 - startTime));console.debug(&quot;Test2 time: &quot; + (test2 - test1));Isto por um tempo pareceu bem interessante, mas bem trabalhoso quando você precisa fazer estes comparativos em objetos e métodos diferentes. Para isso, é necessário armazenar estes dados em variáveis globais e tudo isso atrapalha muito quando você está analisando performance, principalmente quando nem os milissegundos são tão precisos.User Timing APIE agora a música toca bem mais fácil. Com a chegada da User Timing API, tudo parece ficar bem mais simples do que atualmente. A API disponibiliza funções que podem ser chamadas por métodos em diferentes lugares em sua aplicação, para nos levar onde realmente estão os gargalos.Usando mark()Este é o método principal em nosso toolkit. O mark() armazena o timestamp com a chave que foi passada. Pode-se executar o método em vários lugares da aplicação, registrando sempre o timestamp do momento em que foi executado. Inclusive, a especificação sugere uma série de nomes que podem ser interessantes e que são bem auto-explicativos, como mark_fully_loaded, mark_fully_visible, mark_above_the_fold.Por exemplo, poderíamos definir uma mark para quando a aplicação for totalmente carregada usando:window.performance.mark(&#39;mark_fully_loaded&#39;);Pode-se definir varias marks ao longo da aplicação, reunindo bons registros de tempo para analisar e descobrir o que e quando nossa aplicação está fazendo determinada coisa.Calculando medições com measure()Depois de definir seus marks, você precisa medir o tempo decorrido entre eles. Para isso, existe o método measure(). Este método calcula o tempo decorrido entre as marks, e também pode medir o tempo entre seu mark e qualquer um dos nomes de eventos presentes na interface PerformanceTiming.Por exemplo, você pode calcular o tempo entre DOM estar completo até o estado de sua aplicação estar 100% carregada, usando um código como este:window.performance.measure(&#39;measure_load_from_dom&#39;, &#39;domComplete&#39;, &#39;mark_fully_loaded&#39;);// O domComplete é o evento já conhecido pela interface PerformanceTimingQuando o measure() for executado, o resultado será armazenado independente das marks que forem setadas, para que possa ser analisado posteriormente. Isto permitirá que sua aplicação seja completamente executada, e só depois seja feita a análise dos dados.Descartando com clearMarks() e clearMeasures()Algumas vezes pode ser necessário descartar marks que foram setadas e já foram medidas. Por exemplo, se fizer análise em algumas partes da ferramenta, e ao passar para outra parte, já não precise mais daquelas marks. Para isso, pode-se remover todas elas utilizando o clearMarks() sem parâmetros, ou definindo quais que deseja remover:window.peformance.clearMarks(&#39;mark_fully_loaded&#39;);Da mesma forma, também existe o método clearMeasures(), só que desta vez para remover as medições (duh!).window.performance.clearMeasures(&#39;measure_load_from_dom&#39;);Ambas utilizam as mesmas regras. Se não forem passados parâmetros, todas as medições serão removidas. Caso defina os parâmetros, apenas as que forem definidas serão removidas.A hora de fazer acontecerTudo que vimos até agora são as formas de coletar dados e fazer as medições. Agora precisamos coletar e analisar estes dados.Com o método getEntriesByTipe(), permite-se obter todos os tempos das marks ou measures. Ele retornará uma lista em ordem cronológica, para ser visto na ordem em que os fatos aconteceram. Vejamos o código abaixo:var marks = window.performance.getEntriesByType(&#39;mark&#39;),    measures = window.performance.getEntriesByType(&#39;measure&#39;);Também existe o método getEntriesByName() onde você pode usar o nome específico que foi setado na mark ou measure, como o código abaixo:var items = window.performance.getEntriesByName(&#39;mark_fully_loaded&#39;);Isto retornará uma lista com um item (entry) contendo as seguintes propriedades:  name que referencia o nome dado à mark ou measure;  entryType que será uma String ‘mark’ ou ‘measure’;  startTime o timestamp que foi iniciado;  duration um DOMHighResTimeStamp com o tempo (se for uma measure). Caso seja uma mark, retornará valor 0.Mãos à obra!Agora que já conhecemos bem a User Interface API, vamos a um exemplo contendo tudo o que vimos até então.performance.mark(&quot;startFoo&quot;);foo();performance.mark(&quot;endFoo&quot;);// Cria uma measure &quot;durationFoo&quot; que irá medir o tempo entre as marks startFoo e endFooperformance.measure(&quot;durationFoo&quot;, &quot;startFoo&quot;, &quot;endFoo&quot;);// Remove todas as Marksperformance.clearMarks();// Remove a measure &quot;durationFoo&quot;performance.clearMeasure(&quot;durationFoo&quot;);Desta mesma forma, diversos casos podem ser medidos, como alguma ou todas as XHR de sua aplicação, ou apenas algum método específico que deseja analisar.Utilizar esta API não deve ser difícil para testar suas propriedades e métodos. Além disso, o suporte dos navegadores é muito bom. E para aqueles que não a suportam (principalmente o Firefox), um polyfill já está disponível. Então, mãos à obra!"
		} ,
	
		{
		  "title"      : "Fazendo a Web ouvir e falar usando Web Speech API",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/fazendo-a-web-ouvir-e-falar-usando-web-speech-api",
		  "date"       : "2014-01-17 15:00:00 UTC",
		  "shortdate"  : "January 17, 2014",
		  "content"    : "A Web Speech API adiciona voice recognition (reconhecimento de voz, ou seja, voz para texto) e speech synthesis (pronúncia de texto, ou seja, texto para voz). Neste post, iremos abordar as duas funcionalidades, mas com mais detalhes nesta última interface, por ser mais recente e já poder ser testada na última versão do Google Chrome Canary.Speech Synthesis InterfacePara o uso mais básico da API, é mais fácil que tirar pirulito de criança. Olha só!var msg = new SpeechSynthesisUtterance(&#39;more things dot io&#39;);window.speechSynthesis.speak(msg);Entretanto, também pode alterar alguns parâmetros como volume, velocidade da fala, pitch, voz e idioma, como vemos à seguir:var msg = new SpeechSynthesisUtterance();var voices = window.speechSynthesis.getVoices();msg.voice = voices[10]; // Obs: algumas vozes não dão suporte a alterar alguns parâmetrosmsg.voiceURI = &#39;native&#39;;msg.volume = 1; // 0 to 1msg.rate = 1; // 0.1 to 10msg.pitch = 2; //0 to 2msg.text = &#39;Hello World&#39;;msg.lang = &#39;en-US&#39;;msg.onend = function(e) {  console.log(&#39;Finished in &#39; + event.elapsedTime + &#39; seconds.&#39;);};speechSynthesis.speak(msg);Setando a vozA API também possibilita termos uma lista das vozes que estão sendo suportadas.speechSynthesis.getVoices().forEach(function(voice) {  console.log(voice.name, voice.default ? &#39;(default)&#39; :&#39;&#39;);});Para setar uma voz diferente, basta setar no parâmetro voice do objeto instanciado, como vemos abaixo:var msg = new SpeechSynthesisUtterance(&#39;I see dead people!&#39;);msg.voice = speechSynthesis.getVoices().filter(function(voice) { return voice.name == &#39;Whisper&#39;; })[0];speechSynthesis.speak(msg);Suporte dos browsersApenas o Chrome 33 (por enquanto, o Canary) tem o suporte completo a Web Speech API, enquanto o Safari do iOS7 tem suporte parcial. Mas isto não é nada demais, quando podemos usar feature detection, como vemos abaixo:if (&#39;speechSynthesis&#39; in window) { // Synthesis support. Make your web apps talk!}if (&#39;SpeechRecognition&#39; in window) {  // Speech recognition support. Talk to your apps!}Para testar, baixe a versão mais recente do Google Chrome Canary. Após instalá-lo, você pode testar através da demonstração criada pelo Eric Bidelman, chamada “More Awesome Web: features you’ve always wanted” apresentada na Google I/O 2013.Speech Recognition InterfaceA Web Speech API possibilita adicionar bem facilmente reconhecimento de voz em suas páginas. Esta API possibilita um controle fino e flexível no reconhecimento de voz, e por já ter suas definições anteriormente que a Speech Synthesis Interface, já encontra-se disponível desde o Chrome versão 25+. Para entender melhor, iremos nos basear nesta demonstração apresentada na Google I/O 2013, que é bem interessante.var recognition = new webkitSpeechRecognition();recognition.continuous = true;recognition.interimResults = true;recognition.onstart = function() { ... }recognition.onresult = function(event) { ... }recognition.onerror = function(event) { ... }recognition.onend = function() { ... }O valor padrão para continuous é false, o que significa que quando o usuário parar de falar, o reconhecimento de voz vai acabar. Isto é ótimo para textos curtos, mas na demonstração, deixamos como true para o reconhecimento continuar mesmo se o usuário fizer uma pausa enquanto fala.O valor padrão para interimResults também é false, o que significa que apenas os resultados que forem retornados pelo “reconhecedor” são finais e não podem ser alterados.Para iniciar, o usuário clica no microfone ao lado e é disparado o método start() instanciado no objeto recognition.function startButton(event) {  recognition.lang = select_dialect.value;  recognition.start();}Ao iniciar a captura de áudio, ele chama o handler onstart, e em seguida, para cada novo conjunto de palavras, ele chama o handler onresult.recognition.onresult = function(event) {    var interim_transcript = &#39;&#39;;    for (var i = event.resultIndex; i &lt; event.results.length; ++i) {        if (event.results[i].isFinal) {            final_transcript += event.results[i][0].transcript;        } else {            interim_transcript += event.results[i][0].transcript;        }    }}Este handler concatena todos os resultados recebidos em duas strings: final_transcript e interim_transcript. A primeira vai ser sempre todo o conteúdo transcrito, enquanto a última é esvaziada sempre que o handler é chamado.Você pode fazer um teste através desta demonstração criada pela equipe do Google ChromeQual a dificuldade?Pois é, muito simples não é? Isto acontece com quase todas as APIs que são lançadas. Um pouquinho de estudo já faz com que você se torne um bom conhecedor do assunto. Não esquece de dar seu feedback abaixo :)"
		} ,
	
		{
		  "title"      : "Como configurar um servidor node.js para produção",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/node/como-configurar-um-servidor-nodejs-para-producao",
		  "date"       : "2014-01-16 20:00:00 UTC",
		  "shortdate"  : "January 16, 2014",
		  "content"    : "Neste post, estou assumindo que você já possui sua VPS instalada e configurada com o Ubuntu Server. Optei pelo Ubuntu, por ser uma distribuição super simples de configurar. Caso você não possua, aqui vão algumas opções:  Amazon EC2  Linode  WebbyNode  Digital OceanApós o jabá gratuito, o primeiro passo, é você facilitar futuros acessos a máquina, guardando sua chave pública (~/.ssh/id_rsa.pub). Se você não sabe como gerar sua chave, siga este tutorial. O motivo deste procedimento é para você não precisar digitar sua senha toda as vezes que acessar a VPS.SSH keySe você utiliza Mac, aqui vai uma dica super simples para copiar sua chave:cat ~/.ssh/id_rsa.pub | pbcopyCom este comando, sua chave já estará no seu clipboard para colar no servidor. Com sua chave em mãos, vamos nos conectar à vps e executar os seguintes comandos:ssh usuario@ip-de-sua-vps # Ele vai solicitar sua senha desta vez.cd ~/.ssh # Caso o diretório .ssh não exista, você deve criá-lo: mkdir ~/.sshvi authorized_keysCaso o arquivo não exista, digite touch authorized_keys. Em alguns casos você precisará utilizar sudo. Então, sudo touch authorized_keys e sudo vi authorized_keys.Com o arquivo aberto no terminal, digite a tecla i para entrar em modo de edição no vi. Com o modo de edição ativado, cole sua chave que já deve estar no seu clipboard. (cmd + v para macs) e (control + v) para Windows/Linux. Com sua chave colada, aperte esc para voltar ao modo de leitura e em seguida x para salvar e fechar ao mesmo tempo.Pronto, ssh key copiada! Caso você tenha criado o arquivo authorized_keys, você vai precisar executar este comando para que o que fizemos tenha feito:sudo chmod 444 ~/.ssh/authorized_keysEsta forma de copiar a chave é bem manual, mas serve como aprendizado.Outra forma muito útil de copiar sua chave é utilizando ssh-copy-id. Se você utiliza Ubuntu por exemplo é só utilizar o comando. Se você é usuário Mac, você pode instalar através do brew install ssh-copy-id. Para utilizar é muito simples:ssh-copy-id user@hostname.example.comAgora, da próxima vez que você acessar sua VPS ssh user@ip-de-sua-vps, não haverá necessidade de digitar sua senha.Seguindo.. GIT!Para nosso deploy, nós utilizaremos o GIT e o forever. Para isso, precisamos instalar o git na VPS. Para verificar se você já possui o git instalado, digite which git. Se você receber a mensagem “git not found”, vamos instalá-lo através do seguinte comando:sudo apt-get install gitProvavelmente a instalação pedirá para você apertar Y para concordar em baixar os arquivos.Com o GIT instalado, nos resta começar a brincar de instalar o NODE e logo menos, o forever para manter sua aplicação rodando em background.Instalando o NodePara instalar o node, vamos utilizar o apt-get, porém, os pacotes nem sempre estão atualizados como deveriam, então, para garantir que seja instalada a versão mais nova do node, vamos informar ao apt-get que desejamos um repositório específico para baixar o node:sudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install nodejsCom o node instalado, vamos testar se funcionou digitando node --version. Pronto, você já deve estar com o node instalado e consequentemente o npm, já que o mesmo vem “built-in” já faz algum tempo.Vamos ao exemplo! Finalmente, node!Navegue até a pasta de seu usuário, Vamos clonar uma aplicação Express já existente para facilitar nosso trabalho.cd ~git clone https://github.com/djalmaaraujo/express-js-example-blogcd express-js-example-blogSe você tentar rodar node app.js, você vai receber alguns erros, uma vez que precisamos instalar as dependências. Para isso, vamos utilizar o ```npm install``. Depois de algum tempo e muito output, o final se parecerá com isso:......express@3.4.7 node_modules/express├── methods@0.1.0├── merge-descriptors@0.0.1├── cookie-signature@1.0.1doctype html├── range-parser@0.0.4├── fresh@0.2.0├── debug@0.7.4├── buffer-crc32@0.2.1├── cookie@0.1.0├── mkdirp@0.3.5├── send@0.1.4 (mime@1.2.11)├── commander@1.3.2 (keypress@0.1.0)└── connect@2.12.0 (uid2@0.0.3, pause@0.0.1, qs@0.6.6, bytes@0.2.1, raw-body@1.1.2, batch@0.5.0, negotiator@0.3.0, multiparty@2.2.0)Pronto! Estamos prontos para rodar nossa primeira aplicação node em nossa VPS. Para isso, digite node app.js ou apenas node app. Com isso você receberá a seguinte mensagem:Express server listening on port 3000Agora, você deve acessar sua VPS no browser, http://ip-de-sua-vps:3000. Você verá a tela do express inicial:ExpressWelcome to ExpressE agora?Perfeito! Agora nós temos nossa aplicação rodando e já podemos efetuar testes. Mas ninguém gosta de acessar sites na porta 3000, correto? Para configurar nossa porta 80, nós faremos mais algumas coisas.Por padrão, o Ubuntu server vem com porta 80 bloqueada em seu firewall e além disso, para não ter necessidade de ficar “cascavilhando” e brigando com firewall e etc, vamos manter nossa aplicação rodando na porta 3000 e redirecionar a porta 80. Assim, quando os usuários acessarem seu app, a porta 80 será redirecionada para a porta 3000 em background.Não, seu browser não será redirecionado para :3000Para isso vamos primeiro checar se o “ip forwarding” está ativado na máquina. cat /proc/sys/net/ipv4/ip_forward vai te dizer se está ativado ou não. Caso você receba 0, para habilitar utilize as seguintes instruções:sudo vi /etc/sysctl.confnet.ipv4.ip_forward # Descomente esta linha no arquivo aberto. Salve e feche o arquivo.sudo sysctl -p /etc/sysctl.conf # Para ativar as modificações feitas no arquivo.cat /proc/sys/net/ipv4/ip_forward # Para verificar se agora está ativado.Com o “port forwarding” ativado, agora vamos ativar nosso redirecionamento da porta 80 para a porta 3000, utilizando iptables.sudo iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3000Como dito acima, por padrão a porta 80 é bloqueada no firewall, então vamos permitir conexões através desta porta:sudo iptables -A INPUT -p tcp -m tcp --sport 80 -j ACCEPTsudo iptables -A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPTReiniciando a aplicaçãoVá até sua aplicação, inicie a mesma node app, e verifique agora no seu browser, que você pode acessar sua máquina através da porta 80. http://ip-de-sua-maquina. O output da aplicação continuará dizendo listening on port 3000, mas agora sua porta 80 está sendo redirecionada para a 3000.Mais um passo para a vitória. Colocando a aplicação para rodar em background com foreverVamos começar instalado o forever, através do npm.[sudo] npm install forever -gPara utilizar o forever é extremamente simples, apenas saiba o path de sua aplicação e digite o seguinte comando:forever start /home/seuusuario/express-js-example-blog/app.jsCom isso, você terá o seguinte output:warn:    --minUptime not set. Defaulting to: 1000mswarn:    --spinSleepTime not set. Your script will exit if it does not stay up for at least 1000msinfo:    Forever processing file: app.jsVocê percebeu que agora, seu console ficou livre para efetuar outras operações. Isso acontece devido ao forever colocar o processo do node em background.Aqui vão algumas dicas para você interagir mais com o forever:  forever list Lista todas as suas aplicações iniciadas com o forever.  tail -f /path/para/o/log/fornecido.log Você pode verificar o log de sua aplicação em tempo real.  forever stopall Para todas as aplicações  forever stop ID Para uma aplicação específica. Para conseguir o id, digite forever list.Mais detalhes, acesse: https://github.com/nodejitsu/foreverUp and running!Seguindo todos estes passos, você terá sua VPS configurada para rodar suas aplicações node sem se preocupar em utilizar hosts de terceiros.Existem diversas formas de se fazer setup de aplicações, e esta nem é a melhor, nem a pior, mas funciona. Se você estiver trabalhando em um projeto pequeno e que você não está preocupado em ter acesso root a máquina, eu recomendo fortemente que você utilize o Heroku para deploy de suas aplicações node/ruby/whatever.Para o setup no heroku, você pode seguir este simples “Getting started”: https://devcenter.heroku.com/articles/getting-started-with-nodejs, mas isso é assunto para outro post.Comentem, reclamem, corrijam! Até mais!"
		} ,
	
		{
		  "title"      : "Gulp JS: como se tornar Expert em minutos",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/gulpjs-como-se-tornar-expert-em-minutos",
		  "date"       : "2014-01-07 20:00:00 UTC",
		  "shortdate"  : "January 07, 2014",
		  "content"    : "Pra começar bem o ano, já tivemos o anúncio do Gulp JS. Gulp é um automatizador de tarefas escrito em JavaScript. Ele é uma alternativa para o, atualmente mais popular, GruntJS. Automatizar tarefas não é uma novidade. Algumas figurinhas já são bem conhecidas, como o ant para Java, rake para Ruby, entre outras. Mas todas seguem com um grande objetivo em comum: minimizar trabalho repetitivo. E pra manter a qualidade dos nossos projetos, não podemos deixar de estudar as opções que temos.Comparado com o Grunt, senti algumas vantagens interessantes, sendo mais simples e com menos configurações necessárias no código das tasks. O Gulpfile também aparenta ter um entendimento mais fácil, e consequentemente mais rápido.E no dia 3 de Janeiro, já tivemos o seguinte anúncio no Twitter oficial:A velocidade que está sendo feito os plugins é incrível. É um projeto muito recente e já tem muita contribuição da comunidade para conseguir avançar e nos ajudar cada vez mais em nossos projetos. Sem muito blá blá blá, vamos à pratica para ver sua simplicidade.Como base, segue abaixo um simples Gruntfile (script para Grunt), usado para rodar as seguintes tarefas:  Rodar os testes  JSHint nos arquivos JavaScript  Concat nos arquivos JavaScript  Minificar os arquivos  Rodar novamente sempre que os arquivos forem alterados (watch)module.exports = function(grunt) {  grunt.initConfig({    pkg: grunt.file.readJSON(&#39;package.json&#39;),    concat: {      options: {        separator: &#39;;&#39;      },      dist: {        src: [&#39;src/**/*.js&#39;],        dest: &#39;dist/&lt;%= pkg.name %&gt;.js&#39;      }    },    uglify: {      options: {        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;dd-mm-yyyy&quot;) %&gt; */\n&#39;      },      dist: {        files: {          &#39;dist/&lt;%= pkg.name %&gt;.min.js&#39;: [&#39;&lt;%= concat.dist.dest %&gt;&#39;]        }      }    },    qunit: {      files: [&#39;test/**/*.html&#39;]    },    jshint: {      files: [&#39;gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;],      options: {        // options here to override JSHint defaults        globals: {          jQuery: true,          console: true,          module: true,          document: true        }      }    },    watch: {      files: [&#39;&lt;%= jshint.files %&gt;&#39;],      tasks: [&#39;jshint&#39;, &#39;qunit&#39;]    }  });  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-qunit&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);  grunt.registerTask(&#39;test&#39;, [&#39;jshint&#39;, &#39;qunit&#39;]);  grunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;qunit&#39;, &#39;concat&#39;, &#39;uglify&#39;]);};Segue abaixo um exemplo do gulpfile.js, similar ao Gruntfile acima, escrito para o GulpJS :)var gulp = require(&#39;gulp&#39;);var pkg = require(&#39;./package.json&#39;);var concat = require(&#39;gulp-concat&#39;);var minify = require(&#39;gulp-minify&#39;);var jshint = require(&#39;gulp-jshint&#39;);var spawn = require(&#39;child_process&#39;).spawn;var scriptFiles = &#39;./src/**/*.js&#39;;gulp.task(&#39;compile&#39;, function(){  // concat all scripts, minify, and output  gulp.src(scriptFiles)    .pipe(concat({fileName: pkg.name+&quot;.js&quot;})    .pipe(minify())    .pipe(gulp.dest(&#39;./dist/&#39;));});gulp.task(&#39;test&#39;, function(){  // lint our scripts  gulp.src(scriptFiles).pipe(jshint());Quais as diferenças?  Você utiliza o padrão do Gulp para fazer as tarefas básicas  Plugins são simples e fazem apenas uma coisa. A maioria são apenas uma função com 20 linhas em média  As tarefas são executadas de forma encadeada  O código é bem menor e a curva de aprendizado também :)  O Gulp não faz nada, apenas fornece um sistema básico de tarefasLearning…Como aprender Gulp? São 5 tarefas básicas que você precisa entender. São elas:gulp.task(name, fn)Isto registra uma função com um nome.Você pode opcionalmente especificar algumas dependências se outras tarefas precisam rodar antes.gulp.run(tasks…)Roda todas as tarefas de forma encadeadagulp.watch(glob, fn)Roda a função quando o arquivo tiver alterações(*) Incluido no core para simplificargulp.src(glob)Os arquivos que serão lidos no fluxo, e inicia a emissão do arquivo correspondente, podendo ser usado em outros fluxos.gulp.dest(folder)Isto irá retornar o resultado do fluxo, e será salvo no destino (similar ao writeFile() do FileSystem, para quem já está acostumado com Node).Pois é. Estes são os 5 métodos padrões do Gulp. E todos eles são usados no código de exemplo acima para facilitar o entendimento.Parabéns!Como a própria documentação diz, você agora tornou-se expert em Gulp! :)"
		} ,
	
		{
		  "title"      : "Novas collections do EcmaScript 6",
		  "category"   : "",
		  "url"        : "http://www.morethings.io/javascript/novas-collections-do-ecmascript-6",
		  "date"       : "2013-12-19 10:00:00 UTC",
		  "shortdate"  : "December 19, 2013",
		  "content"    : "Para quem estava no Front in Recife, e acompanhou a minha palestra junto com Guilherme Farias ja teve um spoiler do post, visto que apresentamos la um pouco sobre as novas collections, bem como outras novidades do ECMAScript 6.O que são collections?Em toda a história do JavaScript, houve apenas um tipo de collection representado pelo Array. Em outras linguagens como Python, Ruby e Java, já existem outras collections, e com a especificação do ECMAScript 6, também poderemos usá-las. Os novos tipos permitem o armazenamento melhor e mais eficiente de dados.SetsSets são listas ordenadas de valores que não permite valores duplicados. Normalmente você não acessa itens que foram setados, como normalmente fazemos com Arrays, ao invés disso, é mais comum verificar o conjunto para ver se um valor está presente.Permite-se adicionar valores usando o método add() e verificar quantos itens estão no set usando size().var items = new Set();items.add(5);items.add(&quot;5&quot;);console.log(items.size()); // 2items.add(5); // ja existe, sera ignoradoconsole.log(items.size()); // 2Pode-se verificar se algum item está no set usando o método has(). Para remover algum valor, basta usar o método remove().console.log(items.has(5)); // trueitems.delete(5)console.log(items.has(5)); // falseMapsÉ bem parecido com os sets, mas a ideia básica do map é que possui uma chave única, que você pode setar ou verificar a qualquer momento usando esta chave. Em JavaScript, os desenvolvedores tradicionalmente usam objetos regulares como Maps. Inclusive o próprio JSON é baseado neste conceito que representa pares de chave/valor.var map = new Map();map.set(&quot;cor&quot;, &quot;verde&quot;);console.log(map.has(&quot;cor&quot;));   // trueconsole.log(map.get(&quot;cor&quot;));   // &quot;verde&quot;console.log(map.size());       // 1map.delete(&quot;cor&quot;);console.log(map.has(&quot;cor&quot;));   // falseconsole.log(map.get(&quot;cor&quot;));   // undefinedconsole.log(map.size());       // 0WeakMapsBem parecido com os maps, os weakmaps também são baseados em chave/valor. Porém, a chave não pode ser um tipo primitivo (String, por exemplo). Ao invés disso, a chave deve ser um objeto. Isto pode parecer estranho, mas isto é bastante útil em algumas situações.var map = new WeakMap(),    element = document.querySelector(&quot;.element&quot;);map.set(element, &quot;valor qualquer&quot;);var value = map.get(element);console.log(value); // &quot;valor qualquer&quot;element.parentNode.removeChild(element);element = null;value = map.get(element);console.log(value); // undefined"
		} 
	
]